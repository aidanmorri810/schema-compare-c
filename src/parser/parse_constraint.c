#include "parser.h"
#include "sc_memory.h"
#include "utils.h"
#include <stdlib.h>
#include <string.h>

/* Forward declarations */
static bool parse_constraint_attributes(Parser *parser, ColumnConstraint *constraint);

/* Parse column constraint */
ColumnConstraint *parse_column_constraint(Parser *parser) {
    ColumnConstraint *constraint = column_constraint_alloc(parser->memory_ctx);
    if (!constraint) {
        parser_error(parser, "Out of memory");
        return NULL;
    }

    /* Initialize */
    constraint->constraint_name = NULL;
    constraint->has_deferrable = false;
    constraint->has_initially = false;
    constraint->has_enforced = false;
    constraint->next = NULL;

    /* Optional constraint name */
    if (parser_match(parser, TOKEN_CONSTRAINT)) {
        if (!parser_check(parser, TOKEN_IDENTIFIER)) {
            parser_error(parser, "Expected constraint name after CONSTRAINT");
            return NULL;
        }
        constraint->constraint_name = strdup(parser->current.lexeme);
        parser_advance(parser);
    }

    /* Parse constraint type */
    if (parser_match(parser, TOKEN_NOT)) {
        if (!parser_expect(parser, TOKEN_NULL, "Expected NULL after NOT")) {
            return NULL;
        }
        constraint->type = CONSTRAINT_NOT_NULL;
        constraint->constraint.not_null.no_inherit = false;
        if (parser_match(parser, TOKEN_NO)) {
            if (parser_match(parser, TOKEN_INHERIT)) {
                constraint->constraint.not_null.no_inherit = true;
            } else {
                parser_error(parser, "Expected INHERIT after NO");
                return NULL;
            }
        }
    } else if (parser_match(parser, TOKEN_NULL)) {
        constraint->type = CONSTRAINT_NULL;
    } else if (parser_match(parser, TOKEN_CHECK)) {
        constraint->type = CONSTRAINT_CHECK;
        if (!parser_expect(parser, TOKEN_LPAREN, "Expected '(' after CHECK")) {
            return NULL;
        }
        Expression *expr = parse_expression(parser);
        if (!expr) {
            return NULL;
        }
        if (!parser_expect(parser, TOKEN_RPAREN, "Expected ')' after CHECK expression")) {
            return NULL;
        }
        constraint->constraint.check.expr = expr;
        constraint->constraint.check.no_inherit = false;
        if (parser_match(parser, TOKEN_NO)) {
            if (parser_match(parser, TOKEN_INHERIT)) {
                constraint->constraint.check.no_inherit = true;
            }
        }
    } else if (parser_match(parser, TOKEN_DEFAULT)) {
        constraint->type = CONSTRAINT_DEFAULT;
        Expression *expr = parse_expression(parser);
        if (!expr) {
            return NULL;
        }
        constraint->constraint.default_val.expr = expr;
    } else if (parser_match(parser, TOKEN_GENERATED)) {
        if (parser_match(parser, TOKEN_ALWAYS)) {
            if (!parser_expect(parser, TOKEN_AS, "Expected AS after GENERATED ALWAYS")) {
                return NULL;
            }
            if (!parser_expect(parser, TOKEN_LPAREN, "Expected '(' after AS")) {
                return NULL;
            }
            Expression *expr = parse_expression(parser);
            if (!expr) {
                return NULL;
            }
            if (!parser_expect(parser, TOKEN_RPAREN, "Expected ')' after expression")) {
                return NULL;
            }
            constraint->type = CONSTRAINT_GENERATED_ALWAYS;
            constraint->constraint.generated_always.expr = expr;
            constraint->constraint.generated_always.has_storage = false;
            if (parser_match(parser, TOKEN_STORED)) {
                constraint->constraint.generated_always.storage = GENERATED_STORED;
                constraint->constraint.generated_always.has_storage = true;
            } else if (parser_match(parser, TOKEN_VIRTUAL)) {
                constraint->constraint.generated_always.storage = GENERATED_VIRTUAL;
                constraint->constraint.generated_always.has_storage = true;
            }
        } else if (parser_match(parser, TOKEN_BY)) {
            if (!parser_expect(parser, TOKEN_DEFAULT, "Expected DEFAULT after GENERATED BY")) {
                return NULL;
            }
            if (!parser_expect(parser, TOKEN_AS, "Expected AS after GENERATED BY DEFAULT")) {
                return NULL;
            }
            if (!parser_expect(parser, TOKEN_IDENTITY, "Expected IDENTITY after AS")) {
                return NULL;
            }
            constraint->type = CONSTRAINT_GENERATED_IDENTITY;
            constraint->constraint.generated_identity.type = IDENTITY_BY_DEFAULT;
            constraint->constraint.generated_identity.sequence_opts = NULL;
            /* TODO: Parse sequence options */
        } else {
            parser_error(parser, "Expected ALWAYS or BY DEFAULT after GENERATED");
            return NULL;
        }
    } else if (parser_match(parser, TOKEN_UNIQUE)) {
        constraint->type = CONSTRAINT_UNIQUE;
        constraint->constraint.unique.has_nulls_distinct = false;
        constraint->constraint.unique.index_params = NULL;
        /* TODO: Parse NULLS DISTINCT/NOT DISTINCT and index parameters */
    } else if (parser_match(parser, TOKEN_PRIMARY)) {
        if (!parser_expect(parser, TOKEN_KEY, "Expected KEY after PRIMARY")) {
            return NULL;
        }
        constraint->type = CONSTRAINT_PRIMARY_KEY;
        constraint->constraint.primary_key.index_params = NULL;
        /* TODO: Parse index parameters */
    } else if (parser_match(parser, TOKEN_REFERENCES)) {
        constraint->type = CONSTRAINT_REFERENCES;

        /* Parse referenced table */
        if (!parser_check(parser, TOKEN_IDENTIFIER)) {
            parser_error(parser, "Expected table name after REFERENCES");
            return NULL;
        }
        constraint->constraint.references.reftable = strdup(parser->current.lexeme);
        parser_advance(parser);

        /* Optional column name */
        constraint->constraint.references.refcolumn = NULL;
        if (parser_match(parser, TOKEN_LPAREN)) {
            if (!parser_check(parser, TOKEN_IDENTIFIER)) {
                parser_error(parser, "Expected column name");
                return NULL;
            }
            constraint->constraint.references.refcolumn = strdup(parser->current.lexeme);
            parser_advance(parser);
            if (!parser_expect(parser, TOKEN_RPAREN, "Expected ')' after column name")) {
                return NULL;
            }
        }

        /* Initialize optional fields */
        constraint->constraint.references.has_match_type = false;
        constraint->constraint.references.has_on_delete = false;
        constraint->constraint.references.has_on_update = false;

        /* Parse MATCH type */
        if (parser_match(parser, TOKEN_MATCH)) {
            constraint->constraint.references.has_match_type = true;
            if (parser_match(parser, TOKEN_FULL)) {
                constraint->constraint.references.match_type = MATCH_FULL;
            } else if (parser_match(parser, TOKEN_PARTIAL)) {
                constraint->constraint.references.match_type = MATCH_PARTIAL;
            } else if (parser_match(parser, TOKEN_SIMPLE)) {
                constraint->constraint.references.match_type = MATCH_SIMPLE;
            } else {
                parser_error(parser, "Expected FULL, PARTIAL, or SIMPLE after MATCH");
                return NULL;
            }
        }

        /* Parse ON DELETE */
        if (parser_match(parser, TOKEN_ON)) {
            if (parser_match(parser, TOKEN_DELETE)) {
                constraint->constraint.references.has_on_delete = true;
                if (parser_match(parser, TOKEN_NO)) {
                    if (!parser_expect(parser, TOKEN_ACTION, "Expected ACTION after NO")) {
                        return NULL;
                    }
                    constraint->constraint.references.on_delete = REF_ACTION_NO_ACTION;
                } else if (parser_match(parser, TOKEN_RESTRICT)) {
                    constraint->constraint.references.on_delete = REF_ACTION_RESTRICT;
                } else if (parser_match(parser, TOKEN_CASCADE)) {
                    constraint->constraint.references.on_delete = REF_ACTION_CASCADE;
                } else if (parser_match(parser, TOKEN_SET)) {
                    if (parser_match(parser, TOKEN_NULL)) {
                        constraint->constraint.references.on_delete = REF_ACTION_SET_NULL;
                    } else if (parser_match(parser, TOKEN_DEFAULT)) {
                        constraint->constraint.references.on_delete = REF_ACTION_SET_DEFAULT;
                    } else {
                        parser_error(parser, "Expected NULL or DEFAULT after SET");
                        return NULL;
                    }
                } else {
                    parser_error(parser, "Expected referential action after ON DELETE");
                    return NULL;
                }

                /* Check for ON UPDATE after ON DELETE */
                if (parser_match(parser, TOKEN_ON)) {
                    if (parser_match(parser, TOKEN_UPDATE)) {
                        constraint->constraint.references.has_on_update = true;
                        if (parser_match(parser, TOKEN_NO)) {
                            if (!parser_expect(parser, TOKEN_ACTION, "Expected ACTION after NO")) {
                                return NULL;
                            }
                            constraint->constraint.references.on_update = REF_ACTION_NO_ACTION;
                        } else if (parser_match(parser, TOKEN_RESTRICT)) {
                            constraint->constraint.references.on_update = REF_ACTION_RESTRICT;
                        } else if (parser_match(parser, TOKEN_CASCADE)) {
                            constraint->constraint.references.on_update = REF_ACTION_CASCADE;
                        } else if (parser_match(parser, TOKEN_SET)) {
                            if (parser_match(parser, TOKEN_NULL)) {
                                constraint->constraint.references.on_update = REF_ACTION_SET_NULL;
                            } else if (parser_match(parser, TOKEN_DEFAULT)) {
                                constraint->constraint.references.on_update = REF_ACTION_SET_DEFAULT;
                            }
                        }
                    }
                }
            } else if (parser_match(parser, TOKEN_UPDATE)) {
                /* ON UPDATE without ON DELETE */
                constraint->constraint.references.has_on_update = true;
                if (parser_match(parser, TOKEN_NO)) {
                    if (!parser_expect(parser, TOKEN_ACTION, "Expected ACTION after NO")) {
                        return NULL;
                    }
                    constraint->constraint.references.on_update = REF_ACTION_NO_ACTION;
                } else if (parser_match(parser, TOKEN_RESTRICT)) {
                    constraint->constraint.references.on_update = REF_ACTION_RESTRICT;
                } else if (parser_match(parser, TOKEN_CASCADE)) {
                    constraint->constraint.references.on_update = REF_ACTION_CASCADE;
                } else if (parser_match(parser, TOKEN_SET)) {
                    if (parser_match(parser, TOKEN_NULL)) {
                        constraint->constraint.references.on_update = REF_ACTION_SET_NULL;
                    } else if (parser_match(parser, TOKEN_DEFAULT)) {
                        constraint->constraint.references.on_update = REF_ACTION_SET_DEFAULT;
                    }
                }
            }
        }
    } else {
        parser_error(parser, "Expected constraint type");
        return NULL;
    }

    /* Parse constraint attributes (DEFERRABLE, INITIALLY, ENFORCED) */
    parse_constraint_attributes(parser, constraint);

    return constraint;
}

/* Parse table constraint */
TableConstraint *parse_table_constraint(Parser *parser) {
    TableConstraint *constraint = table_constraint_alloc(parser->memory_ctx);
    if (!constraint) {
        parser_error(parser, "Out of memory");
        return NULL;
    }

    /* Initialize */
    constraint->constraint_name = NULL;
    constraint->has_deferrable = false;
    constraint->has_initially = false;
    constraint->has_enforced = false;
    constraint->next = NULL;

    /* Optional constraint name */
    if (parser_match(parser, TOKEN_CONSTRAINT)) {
        if (!parser_check(parser, TOKEN_IDENTIFIER)) {
            parser_error(parser, "Expected constraint name after CONSTRAINT");
            return NULL;
        }
        constraint->constraint_name = strdup(parser->current.lexeme);
        parser_advance(parser);
    }

    /* Parse constraint type */
    if (parser_match(parser, TOKEN_CHECK)) {
        constraint->type = TABLE_CONSTRAINT_CHECK;
        if (!parser_expect(parser, TOKEN_LPAREN, "Expected '(' after CHECK")) {
            return NULL;
        }
        Expression *expr = parse_expression(parser);
        if (!expr) {
            return NULL;
        }
        if (!parser_expect(parser, TOKEN_RPAREN, "Expected ')' after CHECK expression")) {
            return NULL;
        }
        constraint->constraint.check.expr = expr;
        constraint->constraint.check.no_inherit = false;
    } else if (parser_match(parser, TOKEN_UNIQUE)) {
        constraint->type = TABLE_CONSTRAINT_UNIQUE;
        /* TODO: Parse column list and index parameters */
        parser_error(parser, "UNIQUE table constraints not fully implemented yet");
        return NULL;
    } else if (parser_match(parser, TOKEN_PRIMARY)) {
        if (!parser_expect(parser, TOKEN_KEY, "Expected KEY after PRIMARY")) {
            return NULL;
        }
        constraint->type = TABLE_CONSTRAINT_PRIMARY_KEY;

        /* Parse column list */
        if (!parser_expect(parser, TOKEN_LPAREN, "Expected '(' after PRIMARY KEY")) {
            return NULL;
        }

        /* Parse column names */
        int capacity = 4;
        constraint->constraint.primary_key.columns = malloc(sizeof(char*) * capacity);
        constraint->constraint.primary_key.column_count = 0;

        do {
            if (!parser_check(parser, TOKEN_IDENTIFIER)) {
                parser_error(parser, "Expected column name");
                return NULL;
            }

            if (constraint->constraint.primary_key.column_count >= capacity) {
                capacity *= 2;
                char **new_cols = realloc(constraint->constraint.primary_key.columns,
                                         sizeof(char*) * capacity);
                if (!new_cols) {
                    return NULL;
                }
                constraint->constraint.primary_key.columns = new_cols;
            }

            constraint->constraint.primary_key.columns[constraint->constraint.primary_key.column_count++] =
                strdup(parser->current.lexeme);
            parser_advance(parser);
        } while (parser_match(parser, TOKEN_COMMA));

        if (!parser_expect(parser, TOKEN_RPAREN, "Expected ')' after column list")) {
            return NULL;
        }

        constraint->constraint.primary_key.without_overlaps_column = NULL;
        constraint->constraint.primary_key.index_params = NULL;

    } else if (parser_match(parser, TOKEN_FOREIGN)) {
        if (!parser_expect(parser, TOKEN_KEY, "Expected KEY after FOREIGN")) {
            return NULL;
        }
        constraint->type = TABLE_CONSTRAINT_FOREIGN_KEY;

        /* Parse column list */
        if (!parser_expect(parser, TOKEN_LPAREN, "Expected '(' after FOREIGN KEY")) {
            return NULL;
        }

        int capacity = 4;
        constraint->constraint.foreign_key.columns = malloc(sizeof(char*) * capacity);
        constraint->constraint.foreign_key.column_count = 0;

        do {
            if (!parser_check(parser, TOKEN_IDENTIFIER)) {
                parser_error(parser, "Expected column name");
                return NULL;
            }

            if (constraint->constraint.foreign_key.column_count >= capacity) {
                capacity *= 2;
                char **new_cols = realloc(constraint->constraint.foreign_key.columns,
                                         sizeof(char*) * capacity);
                if (!new_cols) {
                    return NULL;
                }
                constraint->constraint.foreign_key.columns = new_cols;
            }

            constraint->constraint.foreign_key.columns[constraint->constraint.foreign_key.column_count++] =
                strdup(parser->current.lexeme);
            parser_advance(parser);
        } while (parser_match(parser, TOKEN_COMMA));

        if (!parser_expect(parser, TOKEN_RPAREN, "Expected ')' after column list")) {
            return NULL;
        }

        /* Parse REFERENCES */
        if (!parser_expect(parser, TOKEN_REFERENCES, "Expected REFERENCES")) {
            return NULL;
        }

        if (!parser_check(parser, TOKEN_IDENTIFIER)) {
            parser_error(parser, "Expected table name after REFERENCES");
            return NULL;
        }
        constraint->constraint.foreign_key.reftable = strdup(parser->current.lexeme);
        parser_advance(parser);

        /* Parse referenced column list */
        constraint->constraint.foreign_key.refcolumns = NULL;
        constraint->constraint.foreign_key.refcolumn_count = 0;

        if (parser_match(parser, TOKEN_LPAREN)) {
            constraint->constraint.foreign_key.refcolumns = malloc(sizeof(char*) * capacity);

            do {
                if (!parser_check(parser, TOKEN_IDENTIFIER)) {
                    parser_error(parser, "Expected column name");
                    return NULL;
                }

                if (constraint->constraint.foreign_key.refcolumn_count >= capacity) {
                    capacity *= 2;
                    char **new_cols = realloc(constraint->constraint.foreign_key.refcolumns,
                                             sizeof(char*) * capacity);
                    if (!new_cols) {
                        return NULL;
                    }
                    constraint->constraint.foreign_key.refcolumns = new_cols;
                }

                constraint->constraint.foreign_key.refcolumns[constraint->constraint.foreign_key.refcolumn_count++] =
                    strdup(parser->current.lexeme);
                parser_advance(parser);
            } while (parser_match(parser, TOKEN_COMMA));

            if (!parser_expect(parser, TOKEN_RPAREN, "Expected ')' after referenced column list")) {
                return NULL;
            }
        }

        /* Initialize other fields */
        constraint->constraint.foreign_key.period_column = NULL;
        constraint->constraint.foreign_key.ref_period_column = NULL;
        constraint->constraint.foreign_key.has_match_type = false;
        constraint->constraint.foreign_key.has_on_delete = false;
        constraint->constraint.foreign_key.has_on_update = false;
        constraint->constraint.foreign_key.on_delete_columns = NULL;
        constraint->constraint.foreign_key.on_delete_column_count = 0;
        constraint->constraint.foreign_key.on_update_columns = NULL;
        constraint->constraint.foreign_key.on_update_column_count = 0;

        /* Parse ON DELETE and ON UPDATE clauses */
        if (parser_match(parser, TOKEN_ON)) {
            if (parser_match(parser, TOKEN_DELETE)) {
                constraint->constraint.foreign_key.has_on_delete = true;
                if (parser_match(parser, TOKEN_NO)) {
                    if (!parser_expect(parser, TOKEN_ACTION, "Expected ACTION after NO")) {
                        return NULL;
                    }
                    constraint->constraint.foreign_key.on_delete = REF_ACTION_NO_ACTION;
                } else if (parser_match(parser, TOKEN_RESTRICT)) {
                    constraint->constraint.foreign_key.on_delete = REF_ACTION_RESTRICT;
                } else if (parser_match(parser, TOKEN_CASCADE)) {
                    constraint->constraint.foreign_key.on_delete = REF_ACTION_CASCADE;
                } else if (parser_match(parser, TOKEN_SET)) {
                    if (parser_match(parser, TOKEN_NULL)) {
                        constraint->constraint.foreign_key.on_delete = REF_ACTION_SET_NULL;
                    } else if (parser_match(parser, TOKEN_DEFAULT)) {
                        constraint->constraint.foreign_key.on_delete = REF_ACTION_SET_DEFAULT;
                    } else {
                        parser_error(parser, "Expected NULL or DEFAULT after SET");
                        return NULL;
                    }
                } else {
                    parser_error(parser, "Expected referential action after ON DELETE");
                    return NULL;
                }

                /* Check for ON UPDATE after ON DELETE */
                if (parser_match(parser, TOKEN_ON)) {
                    if (parser_match(parser, TOKEN_UPDATE)) {
                        constraint->constraint.foreign_key.has_on_update = true;
                        if (parser_match(parser, TOKEN_NO)) {
                            if (!parser_expect(parser, TOKEN_ACTION, "Expected ACTION after NO")) {
                                return NULL;
                            }
                            constraint->constraint.foreign_key.on_update = REF_ACTION_NO_ACTION;
                        } else if (parser_match(parser, TOKEN_RESTRICT)) {
                            constraint->constraint.foreign_key.on_update = REF_ACTION_RESTRICT;
                        } else if (parser_match(parser, TOKEN_CASCADE)) {
                            constraint->constraint.foreign_key.on_update = REF_ACTION_CASCADE;
                        } else if (parser_match(parser, TOKEN_SET)) {
                            if (parser_match(parser, TOKEN_NULL)) {
                                constraint->constraint.foreign_key.on_update = REF_ACTION_SET_NULL;
                            } else if (parser_match(parser, TOKEN_DEFAULT)) {
                                constraint->constraint.foreign_key.on_update = REF_ACTION_SET_DEFAULT;
                            } else {
                                parser_error(parser, "Expected NULL or DEFAULT after SET");
                                return NULL;
                            }
                        } else {
                            parser_error(parser, "Expected referential action after ON UPDATE");
                            return NULL;
                        }
                    }
                }
            } else if (parser_match(parser, TOKEN_UPDATE)) {
                /* ON UPDATE without ON DELETE */
                constraint->constraint.foreign_key.has_on_update = true;
                if (parser_match(parser, TOKEN_NO)) {
                    if (!parser_expect(parser, TOKEN_ACTION, "Expected ACTION after NO")) {
                        return NULL;
                    }
                    constraint->constraint.foreign_key.on_update = REF_ACTION_NO_ACTION;
                } else if (parser_match(parser, TOKEN_RESTRICT)) {
                    constraint->constraint.foreign_key.on_update = REF_ACTION_RESTRICT;
                } else if (parser_match(parser, TOKEN_CASCADE)) {
                    constraint->constraint.foreign_key.on_update = REF_ACTION_CASCADE;
                } else if (parser_match(parser, TOKEN_SET)) {
                    if (parser_match(parser, TOKEN_NULL)) {
                        constraint->constraint.foreign_key.on_update = REF_ACTION_SET_NULL;
                    } else if (parser_match(parser, TOKEN_DEFAULT)) {
                        constraint->constraint.foreign_key.on_update = REF_ACTION_SET_DEFAULT;
                    } else {
                        parser_error(parser, "Expected NULL or DEFAULT after SET");
                        return NULL;
                    }
                } else {
                    parser_error(parser, "Expected referential action after ON UPDATE");
                    return NULL;
                }
            }
        }
    } else if (parser_match(parser, TOKEN_EXCLUDE)) {
        constraint->type = TABLE_CONSTRAINT_EXCLUDE;
        /* TODO: Parse exclude constraint */
        parser_error(parser, "EXCLUDE constraints not fully implemented yet");
        return NULL;
    } else {
        parser_error(parser, "Expected table constraint type");
        return NULL;
    }

    return constraint;
}

/* Parse constraint attributes */
static bool parse_constraint_attributes(Parser *parser, ColumnConstraint *constraint) {
    /* Parse DEFERRABLE/NOT DEFERRABLE */
    if (parser_match(parser, TOKEN_DEFERRABLE)) {
        constraint->has_deferrable = true;
        constraint->deferrable = true;
        constraint->not_deferrable = false;
    }
    /* Note: NOT DEFERRABLE parsing is intentionally NOT here because NOT is ambiguous */
    /* (could be NOT NULL, NOT DEFERRABLE, NOT ENFORCED) */
    /* For now, we don't support NOT DEFERRABLE to avoid conflicts with NOT NULL */

    /* Parse INITIALLY DEFERRED/IMMEDIATE */
    if (parser_match(parser, TOKEN_INITIALLY)) {
        constraint->has_initially = true;
        if (parser_match(parser, TOKEN_DEFERRED)) {
            constraint->initially_deferred = true;
            constraint->initially_immediate = false;
        } else if (parser_match(parser, TOKEN_IMMEDIATE)) {
            constraint->initially_deferred = false;
            constraint->initially_immediate = true;
        } else {
            parser_error(parser, "Expected DEFERRED or IMMEDIATE after INITIALLY");
            return false;
        }
    }

    /* Parse ENFORCED/NOT ENFORCED */
    if (parser_match(parser, TOKEN_ENFORCED)) {
        constraint->has_enforced = true;
        constraint->enforced = true;
        constraint->not_enforced = false;
    }
    /* Note: NOT ENFORCED parsing is intentionally NOT here to avoid conflicts with NOT NULL */

    return true;
}

/* Parse expression (simplified - just grab tokens until we hit a delimiter) */
Expression *parse_expression(Parser *parser) {
    StringBuilder *sb = sb_create();
    if (!sb) {
        parser_error(parser, "Out of memory");
        return NULL;
    }

    int paren_depth = 0;
    bool first_token = true;

    while (!parser_check(parser, TOKEN_EOF)) {
        /* Stop at statement/clause delimiters */
        if (paren_depth == 0) {
            if (parser_check(parser, TOKEN_COMMA) ||
                parser_check(parser, TOKEN_SEMICOLON) ||
                parser_check(parser, TOKEN_RPAREN) ||
                parser_check(parser, TOKEN_CHECK) ||
                parser_check(parser, TOKEN_CONSTRAINT) ||
                parser_check(parser, TOKEN_NOT) ||
                parser_check(parser, TOKEN_NULL) ||
                parser_check(parser, TOKEN_UNIQUE) ||
                parser_check(parser, TOKEN_PRIMARY) ||
                parser_check(parser, TOKEN_REFERENCES) ||
                parser_check(parser, TOKEN_COLLATE) ||
                parser_check(parser, TOKEN_NO) ||
                parser_check(parser, TOKEN_DEFERRABLE) ||
                parser_check(parser, TOKEN_INITIALLY) ||
                parser_check(parser, TOKEN_ENFORCED)) {
                break;
            }
        }

        /* Track parentheses */
        if (parser_check(parser, TOKEN_LPAREN)) {
            paren_depth++;
        } else if (parser_check(parser, TOKEN_RPAREN)) {
            if (paren_depth > 0) {
                paren_depth--;
            } else {
                break; /* Unmatched closing paren - end expression */
            }
        }

        /* Append token to expression */
        /* Add space before token unless it's a parenthesis following another token */
        if (!first_token) {
            /* Don't add space before opening paren or after opening paren */
            /* Don't add space before closing paren */
            if (parser->current.type != TOKEN_LPAREN &&
                parser->current.type != TOKEN_RPAREN &&
                parser->previous.type != TOKEN_LPAREN) {
                sb_append_char(sb, ' ');
            }
        }
        first_token = false;
        sb_append(sb, parser->current.lexeme);
        parser_advance(parser);
    }

    char *expr_str = sb_to_string(sb);
    sb_free(sb);

    if (!expr_str || strlen(expr_str) == 0) {
        free(expr_str);
        parser_error(parser, "Expected expression");
        return NULL;
    }

    Expression *expr = expression_alloc(parser->memory_ctx, expr_str);
    free(expr_str);

    return expr;
}
