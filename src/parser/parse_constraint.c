#include "parser.h"
#include "sc_memory.h"
#include "utils.h"
#include <stdlib.h>
#include <string.h>

/* Forward declarations */
static bool parse_constraint_attributes(Parser *parser, ColumnConstraint *constraint);
static SequenceOptions *parse_sequence_options(Parser *parser);
static IndexParameters *parse_index_parameters(Parser *parser);

/* Parse column constraint */
ColumnConstraint *parse_column_constraint(Parser *parser) {
    ColumnConstraint *constraint = column_constraint_alloc(parser->memory_ctx);
    if (!constraint) {
        parser_error(parser, "Out of memory");
        return NULL;
    }

    /* Initialize */
    constraint->constraint_name = NULL;
    constraint->has_deferrable = false;
    constraint->has_initially = false;
    constraint->has_enforced = false;
    constraint->next = NULL;

    /* Optional constraint name */
    if (parser_match(parser, TOKEN_CONSTRAINT)) {
        if (!parser_check(parser, TOKEN_IDENTIFIER)) {
            parser_error(parser, "Expected constraint name after CONSTRAINT");
            return NULL;
        }
        constraint->constraint_name = strdup(parser->current.lexeme);
        parser_advance(parser);
    }

    /* Parse constraint type */
    if (parser_match(parser, TOKEN_NOT)) {
        if (!parser_expect(parser, TOKEN_NULL, "Expected NULL after NOT")) {
            return NULL;
        }
        constraint->type = CONSTRAINT_NOT_NULL;
        constraint->constraint.not_null.no_inherit = false;
        if (parser_match(parser, TOKEN_NO)) {
            if (parser_match(parser, TOKEN_INHERIT)) {
                constraint->constraint.not_null.no_inherit = true;
            } else {
                parser_error(parser, "Expected INHERIT after NO");
                return NULL;
            }
        }
    } else if (parser_match(parser, TOKEN_NULL)) {
        constraint->type = CONSTRAINT_NULL;
    } else if (parser_match(parser, TOKEN_CHECK)) {
        constraint->type = CONSTRAINT_CHECK;
        if (!parser_expect(parser, TOKEN_LPAREN, "Expected '(' after CHECK")) {
            return NULL;
        }
        Expression *expr = parse_expression(parser);
        if (!expr) {
            return NULL;
        }
        if (!parser_expect(parser, TOKEN_RPAREN, "Expected ')' after CHECK expression")) {
            return NULL;
        }
        constraint->constraint.check.expr = expr;
        constraint->constraint.check.no_inherit = false;
        if (parser_match(parser, TOKEN_NO)) {
            if (parser_match(parser, TOKEN_INHERIT)) {
                constraint->constraint.check.no_inherit = true;
            }
        }
    } else if (parser_match(parser, TOKEN_DEFAULT)) {
        constraint->type = CONSTRAINT_DEFAULT;
        Expression *expr = parse_expression(parser);
        if (!expr) {
            return NULL;
        }
        constraint->constraint.default_val.expr = expr;
    } else if (parser_match(parser, TOKEN_GENERATED)) {
        if (parser_match(parser, TOKEN_ALWAYS)) {
            if (!parser_expect(parser, TOKEN_AS, "Expected AS after GENERATED ALWAYS")) {
                return NULL;
            }
            if (!parser_expect(parser, TOKEN_LPAREN, "Expected '(' after AS")) {
                return NULL;
            }
            Expression *expr = parse_expression(parser);
            if (!expr) {
                return NULL;
            }
            if (!parser_expect(parser, TOKEN_RPAREN, "Expected ')' after expression")) {
                return NULL;
            }
            constraint->type = CONSTRAINT_GENERATED_ALWAYS;
            constraint->constraint.generated_always.expr = expr;
            constraint->constraint.generated_always.has_storage = false;
            if (parser_match(parser, TOKEN_STORED)) {
                constraint->constraint.generated_always.storage = GENERATED_STORED;
                constraint->constraint.generated_always.has_storage = true;
            } else if (parser_match(parser, TOKEN_VIRTUAL)) {
                constraint->constraint.generated_always.storage = GENERATED_VIRTUAL;
                constraint->constraint.generated_always.has_storage = true;
            }
        } else if (parser_match(parser, TOKEN_BY)) {
            if (!parser_expect(parser, TOKEN_DEFAULT, "Expected DEFAULT after GENERATED BY")) {
                return NULL;
            }
            if (!parser_expect(parser, TOKEN_AS, "Expected AS after GENERATED BY DEFAULT")) {
                return NULL;
            }
            if (!parser_expect(parser, TOKEN_IDENTITY, "Expected IDENTITY after AS")) {
                return NULL;
            }
            constraint->type = CONSTRAINT_GENERATED_IDENTITY;
            constraint->constraint.generated_identity.type = IDENTITY_BY_DEFAULT;

            /* Parse optional sequence options */
            if (parser_match(parser, TOKEN_LPAREN)) {
                constraint->constraint.generated_identity.sequence_opts = parse_sequence_options(parser);
                if (!constraint->constraint.generated_identity.sequence_opts) {
                    return NULL;
                }
                if (!parser_expect(parser, TOKEN_RPAREN, "Expected ')' after sequence options")) {
                    return NULL;
                }
            } else {
                constraint->constraint.generated_identity.sequence_opts = NULL;
            }
        } else {
            parser_error(parser, "Expected ALWAYS or BY DEFAULT after GENERATED");
            return NULL;
        }
    } else if (parser_match(parser, TOKEN_UNIQUE)) {
        constraint->type = CONSTRAINT_UNIQUE;
        constraint->constraint.unique.has_nulls_distinct = false;

        /* Parse NULLS DISTINCT/NOT DISTINCT */
        if (parser_match(parser, TOKEN_NULLS)) {
            constraint->constraint.unique.has_nulls_distinct = true;
            if (parser_match(parser, TOKEN_NOT)) {
                if (!parser_expect(parser, TOKEN_DISTINCT, "Expected DISTINCT after NOT")) {
                    return NULL;
                }
                constraint->constraint.unique.nulls_distinct = NULLS_NOT_DISTINCT;
            } else if (parser_match(parser, TOKEN_DISTINCT)) {
                constraint->constraint.unique.nulls_distinct = NULLS_DISTINCT;
            } else {
                parser_error(parser, "Expected DISTINCT or NOT DISTINCT after NULLS");
                return NULL;
            }
        }

        /* Parse index parameters */
        constraint->constraint.unique.index_params = parse_index_parameters(parser);
    } else if (parser_match(parser, TOKEN_PRIMARY)) {
        if (!parser_expect(parser, TOKEN_KEY, "Expected KEY after PRIMARY")) {
            return NULL;
        }
        constraint->type = CONSTRAINT_PRIMARY_KEY;

        /* Parse index parameters */
        constraint->constraint.primary_key.index_params = parse_index_parameters(parser);
    } else if (parser_match(parser, TOKEN_REFERENCES)) {
        constraint->type = CONSTRAINT_REFERENCES;

        /* Parse referenced table */
        if (!parser_check(parser, TOKEN_IDENTIFIER)) {
            parser_error(parser, "Expected table name after REFERENCES");
            return NULL;
        }
        constraint->constraint.references.reftable = strdup(parser->current.lexeme);
        parser_advance(parser);

        /* Optional column name */
        constraint->constraint.references.refcolumn = NULL;
        if (parser_match(parser, TOKEN_LPAREN)) {
            if (!parser_check(parser, TOKEN_IDENTIFIER)) {
                parser_error(parser, "Expected column name");
                return NULL;
            }
            constraint->constraint.references.refcolumn = strdup(parser->current.lexeme);
            parser_advance(parser);
            if (!parser_expect(parser, TOKEN_RPAREN, "Expected ')' after column name")) {
                return NULL;
            }
        }

        /* Initialize optional fields */
        constraint->constraint.references.has_match_type = false;
        constraint->constraint.references.has_on_delete = false;
        constraint->constraint.references.has_on_update = false;

        /* Parse MATCH type */
        if (parser_match(parser, TOKEN_MATCH)) {
            constraint->constraint.references.has_match_type = true;
            if (parser_match(parser, TOKEN_FULL)) {
                constraint->constraint.references.match_type = MATCH_FULL;
            } else if (parser_match(parser, TOKEN_PARTIAL)) {
                constraint->constraint.references.match_type = MATCH_PARTIAL;
            } else if (parser_match(parser, TOKEN_SIMPLE)) {
                constraint->constraint.references.match_type = MATCH_SIMPLE;
            } else {
                parser_error(parser, "Expected FULL, PARTIAL, or SIMPLE after MATCH");
                return NULL;
            }
        }

        /* Parse ON DELETE */
        if (parser_match(parser, TOKEN_ON)) {
            if (parser_match(parser, TOKEN_DELETE)) {
                constraint->constraint.references.has_on_delete = true;
                if (parser_match(parser, TOKEN_NO)) {
                    if (!parser_expect(parser, TOKEN_ACTION, "Expected ACTION after NO")) {
                        return NULL;
                    }
                    constraint->constraint.references.on_delete = REF_ACTION_NO_ACTION;
                } else if (parser_match(parser, TOKEN_RESTRICT)) {
                    constraint->constraint.references.on_delete = REF_ACTION_RESTRICT;
                } else if (parser_match(parser, TOKEN_CASCADE)) {
                    constraint->constraint.references.on_delete = REF_ACTION_CASCADE;
                } else if (parser_match(parser, TOKEN_SET)) {
                    if (parser_match(parser, TOKEN_NULL)) {
                        constraint->constraint.references.on_delete = REF_ACTION_SET_NULL;
                    } else if (parser_match(parser, TOKEN_DEFAULT)) {
                        constraint->constraint.references.on_delete = REF_ACTION_SET_DEFAULT;
                    } else {
                        parser_error(parser, "Expected NULL or DEFAULT after SET");
                        return NULL;
                    }
                } else {
                    parser_error(parser, "Expected referential action after ON DELETE");
                    return NULL;
                }

                /* Check for ON UPDATE after ON DELETE */
                if (parser_match(parser, TOKEN_ON)) {
                    if (parser_match(parser, TOKEN_UPDATE)) {
                        constraint->constraint.references.has_on_update = true;
                        if (parser_match(parser, TOKEN_NO)) {
                            if (!parser_expect(parser, TOKEN_ACTION, "Expected ACTION after NO")) {
                                return NULL;
                            }
                            constraint->constraint.references.on_update = REF_ACTION_NO_ACTION;
                        } else if (parser_match(parser, TOKEN_RESTRICT)) {
                            constraint->constraint.references.on_update = REF_ACTION_RESTRICT;
                        } else if (parser_match(parser, TOKEN_CASCADE)) {
                            constraint->constraint.references.on_update = REF_ACTION_CASCADE;
                        } else if (parser_match(parser, TOKEN_SET)) {
                            if (parser_match(parser, TOKEN_NULL)) {
                                constraint->constraint.references.on_update = REF_ACTION_SET_NULL;
                            } else if (parser_match(parser, TOKEN_DEFAULT)) {
                                constraint->constraint.references.on_update = REF_ACTION_SET_DEFAULT;
                            }
                        }
                    }
                }
            } else if (parser_match(parser, TOKEN_UPDATE)) {
                /* ON UPDATE without ON DELETE */
                constraint->constraint.references.has_on_update = true;
                if (parser_match(parser, TOKEN_NO)) {
                    if (!parser_expect(parser, TOKEN_ACTION, "Expected ACTION after NO")) {
                        return NULL;
                    }
                    constraint->constraint.references.on_update = REF_ACTION_NO_ACTION;
                } else if (parser_match(parser, TOKEN_RESTRICT)) {
                    constraint->constraint.references.on_update = REF_ACTION_RESTRICT;
                } else if (parser_match(parser, TOKEN_CASCADE)) {
                    constraint->constraint.references.on_update = REF_ACTION_CASCADE;
                } else if (parser_match(parser, TOKEN_SET)) {
                    if (parser_match(parser, TOKEN_NULL)) {
                        constraint->constraint.references.on_update = REF_ACTION_SET_NULL;
                    } else if (parser_match(parser, TOKEN_DEFAULT)) {
                        constraint->constraint.references.on_update = REF_ACTION_SET_DEFAULT;
                    }
                }
            }
        }
    } else {
        parser_error(parser, "Expected constraint type");
        return NULL;
    }

    /* Parse constraint attributes (DEFERRABLE, INITIALLY, ENFORCED) */
    parse_constraint_attributes(parser, constraint);

    return constraint;
}

/* Parse table constraint */
TableConstraint *parse_table_constraint(Parser *parser) {
    TableConstraint *constraint = table_constraint_alloc(parser->memory_ctx);
    if (!constraint) {
        parser_error(parser, "Out of memory");
        return NULL;
    }

    /* Initialize */
    constraint->constraint_name = NULL;
    constraint->has_deferrable = false;
    constraint->has_initially = false;
    constraint->has_enforced = false;
    constraint->next = NULL;

    /* Optional constraint name */
    if (parser_match(parser, TOKEN_CONSTRAINT)) {
        if (!parser_check(parser, TOKEN_IDENTIFIER)) {
            parser_error(parser, "Expected constraint name after CONSTRAINT");
            return NULL;
        }
        constraint->constraint_name = strdup(parser->current.lexeme);
        parser_advance(parser);
    }

    /* Parse constraint type */
    if (parser_match(parser, TOKEN_CHECK)) {
        constraint->type = TABLE_CONSTRAINT_CHECK;
        if (!parser_expect(parser, TOKEN_LPAREN, "Expected '(' after CHECK")) {
            return NULL;
        }
        Expression *expr = parse_expression(parser);
        if (!expr) {
            return NULL;
        }
        if (!parser_expect(parser, TOKEN_RPAREN, "Expected ')' after CHECK expression")) {
            return NULL;
        }
        constraint->constraint.check.expr = expr;
        constraint->constraint.check.no_inherit = false;
    } else if (parser_match(parser, TOKEN_UNIQUE)) {
        constraint->type = TABLE_CONSTRAINT_UNIQUE;

        /* Parse column list */
        if (!parser_expect(parser, TOKEN_LPAREN, "Expected '(' after UNIQUE")) {
            return NULL;
        }

        int capacity = 4;
        constraint->constraint.unique.columns = malloc(sizeof(char*) * capacity);
        constraint->constraint.unique.column_count = 0;

        do {
            if (!parser_check(parser, TOKEN_IDENTIFIER)) {
                parser_error(parser, "Expected column name");
                return NULL;
            }

            if (constraint->constraint.unique.column_count >= capacity) {
                capacity *= 2;
                char **new_cols = realloc(constraint->constraint.unique.columns,
                                         sizeof(char*) * capacity);
                if (!new_cols) {
                    return NULL;
                }
                constraint->constraint.unique.columns = new_cols;
            }

            constraint->constraint.unique.columns[constraint->constraint.unique.column_count++] =
                strdup(parser->current.lexeme);
            parser_advance(parser);
        } while (parser_match(parser, TOKEN_COMMA));

        if (!parser_expect(parser, TOKEN_RPAREN, "Expected ')' after column list")) {
            return NULL;
        }

        /* Initialize optional fields */
        constraint->constraint.unique.without_overlaps_column = NULL;
        constraint->constraint.unique.has_nulls_distinct = false;

        /* Parse NULLS DISTINCT/NOT DISTINCT */
        if (parser_match(parser, TOKEN_NULLS)) {
            constraint->constraint.unique.has_nulls_distinct = true;
            if (parser_match(parser, TOKEN_NOT)) {
                if (!parser_expect(parser, TOKEN_DISTINCT, "Expected DISTINCT after NOT")) {
                    return NULL;
                }
                constraint->constraint.unique.nulls_distinct = NULLS_NOT_DISTINCT;
            } else if (parser_match(parser, TOKEN_DISTINCT)) {
                constraint->constraint.unique.nulls_distinct = NULLS_DISTINCT;
            } else {
                parser_error(parser, "Expected DISTINCT or NOT DISTINCT after NULLS");
                return NULL;
            }
        }

        /* Parse index parameters */
        constraint->constraint.unique.index_params = parse_index_parameters(parser);
    } else if (parser_match(parser, TOKEN_PRIMARY)) {
        if (!parser_expect(parser, TOKEN_KEY, "Expected KEY after PRIMARY")) {
            return NULL;
        }
        constraint->type = TABLE_CONSTRAINT_PRIMARY_KEY;

        /* Parse column list */
        if (!parser_expect(parser, TOKEN_LPAREN, "Expected '(' after PRIMARY KEY")) {
            return NULL;
        }

        /* Parse column names */
        int capacity = 4;
        constraint->constraint.primary_key.columns = malloc(sizeof(char*) * capacity);
        constraint->constraint.primary_key.column_count = 0;

        do {
            if (!parser_check(parser, TOKEN_IDENTIFIER)) {
                parser_error(parser, "Expected column name");
                return NULL;
            }

            if (constraint->constraint.primary_key.column_count >= capacity) {
                capacity *= 2;
                char **new_cols = realloc(constraint->constraint.primary_key.columns,
                                         sizeof(char*) * capacity);
                if (!new_cols) {
                    return NULL;
                }
                constraint->constraint.primary_key.columns = new_cols;
            }

            constraint->constraint.primary_key.columns[constraint->constraint.primary_key.column_count++] =
                strdup(parser->current.lexeme);
            parser_advance(parser);
        } while (parser_match(parser, TOKEN_COMMA));

        if (!parser_expect(parser, TOKEN_RPAREN, "Expected ')' after column list")) {
            return NULL;
        }

        constraint->constraint.primary_key.without_overlaps_column = NULL;
        constraint->constraint.primary_key.index_params = NULL;

    } else if (parser_match(parser, TOKEN_FOREIGN)) {
        if (!parser_expect(parser, TOKEN_KEY, "Expected KEY after FOREIGN")) {
            return NULL;
        }
        constraint->type = TABLE_CONSTRAINT_FOREIGN_KEY;

        /* Parse column list */
        if (!parser_expect(parser, TOKEN_LPAREN, "Expected '(' after FOREIGN KEY")) {
            return NULL;
        }

        int capacity = 4;
        constraint->constraint.foreign_key.columns = malloc(sizeof(char*) * capacity);
        constraint->constraint.foreign_key.column_count = 0;

        do {
            if (!parser_check(parser, TOKEN_IDENTIFIER)) {
                parser_error(parser, "Expected column name");
                return NULL;
            }

            if (constraint->constraint.foreign_key.column_count >= capacity) {
                capacity *= 2;
                char **new_cols = realloc(constraint->constraint.foreign_key.columns,
                                         sizeof(char*) * capacity);
                if (!new_cols) {
                    return NULL;
                }
                constraint->constraint.foreign_key.columns = new_cols;
            }

            constraint->constraint.foreign_key.columns[constraint->constraint.foreign_key.column_count++] =
                strdup(parser->current.lexeme);
            parser_advance(parser);
        } while (parser_match(parser, TOKEN_COMMA));

        if (!parser_expect(parser, TOKEN_RPAREN, "Expected ')' after column list")) {
            return NULL;
        }

        /* Parse REFERENCES */
        if (!parser_expect(parser, TOKEN_REFERENCES, "Expected REFERENCES")) {
            return NULL;
        }

        if (!parser_check(parser, TOKEN_IDENTIFIER)) {
            parser_error(parser, "Expected table name after REFERENCES");
            return NULL;
        }
        constraint->constraint.foreign_key.reftable = strdup(parser->current.lexeme);
        parser_advance(parser);

        /* Parse referenced column list */
        constraint->constraint.foreign_key.refcolumns = NULL;
        constraint->constraint.foreign_key.refcolumn_count = 0;

        if (parser_match(parser, TOKEN_LPAREN)) {
            constraint->constraint.foreign_key.refcolumns = malloc(sizeof(char*) * capacity);

            do {
                if (!parser_check(parser, TOKEN_IDENTIFIER)) {
                    parser_error(parser, "Expected column name");
                    return NULL;
                }

                if (constraint->constraint.foreign_key.refcolumn_count >= capacity) {
                    capacity *= 2;
                    char **new_cols = realloc(constraint->constraint.foreign_key.refcolumns,
                                             sizeof(char*) * capacity);
                    if (!new_cols) {
                        return NULL;
                    }
                    constraint->constraint.foreign_key.refcolumns = new_cols;
                }

                constraint->constraint.foreign_key.refcolumns[constraint->constraint.foreign_key.refcolumn_count++] =
                    strdup(parser->current.lexeme);
                parser_advance(parser);
            } while (parser_match(parser, TOKEN_COMMA));

            if (!parser_expect(parser, TOKEN_RPAREN, "Expected ')' after referenced column list")) {
                return NULL;
            }
        }

        /* Initialize other fields */
        constraint->constraint.foreign_key.period_column = NULL;
        constraint->constraint.foreign_key.ref_period_column = NULL;
        constraint->constraint.foreign_key.has_match_type = false;
        constraint->constraint.foreign_key.has_on_delete = false;
        constraint->constraint.foreign_key.has_on_update = false;
        constraint->constraint.foreign_key.on_delete_columns = NULL;
        constraint->constraint.foreign_key.on_delete_column_count = 0;
        constraint->constraint.foreign_key.on_update_columns = NULL;
        constraint->constraint.foreign_key.on_update_column_count = 0;

        /* Parse ON DELETE and ON UPDATE clauses */
        if (parser_match(parser, TOKEN_ON)) {
            if (parser_match(parser, TOKEN_DELETE)) {
                constraint->constraint.foreign_key.has_on_delete = true;
                if (parser_match(parser, TOKEN_NO)) {
                    if (!parser_expect(parser, TOKEN_ACTION, "Expected ACTION after NO")) {
                        return NULL;
                    }
                    constraint->constraint.foreign_key.on_delete = REF_ACTION_NO_ACTION;
                } else if (parser_match(parser, TOKEN_RESTRICT)) {
                    constraint->constraint.foreign_key.on_delete = REF_ACTION_RESTRICT;
                } else if (parser_match(parser, TOKEN_CASCADE)) {
                    constraint->constraint.foreign_key.on_delete = REF_ACTION_CASCADE;
                } else if (parser_match(parser, TOKEN_SET)) {
                    if (parser_match(parser, TOKEN_NULL)) {
                        constraint->constraint.foreign_key.on_delete = REF_ACTION_SET_NULL;
                    } else if (parser_match(parser, TOKEN_DEFAULT)) {
                        constraint->constraint.foreign_key.on_delete = REF_ACTION_SET_DEFAULT;
                    } else {
                        parser_error(parser, "Expected NULL or DEFAULT after SET");
                        return NULL;
                    }
                } else {
                    parser_error(parser, "Expected referential action after ON DELETE");
                    return NULL;
                }

                /* Check for ON UPDATE after ON DELETE */
                if (parser_match(parser, TOKEN_ON)) {
                    if (parser_match(parser, TOKEN_UPDATE)) {
                        constraint->constraint.foreign_key.has_on_update = true;
                        if (parser_match(parser, TOKEN_NO)) {
                            if (!parser_expect(parser, TOKEN_ACTION, "Expected ACTION after NO")) {
                                return NULL;
                            }
                            constraint->constraint.foreign_key.on_update = REF_ACTION_NO_ACTION;
                        } else if (parser_match(parser, TOKEN_RESTRICT)) {
                            constraint->constraint.foreign_key.on_update = REF_ACTION_RESTRICT;
                        } else if (parser_match(parser, TOKEN_CASCADE)) {
                            constraint->constraint.foreign_key.on_update = REF_ACTION_CASCADE;
                        } else if (parser_match(parser, TOKEN_SET)) {
                            if (parser_match(parser, TOKEN_NULL)) {
                                constraint->constraint.foreign_key.on_update = REF_ACTION_SET_NULL;
                            } else if (parser_match(parser, TOKEN_DEFAULT)) {
                                constraint->constraint.foreign_key.on_update = REF_ACTION_SET_DEFAULT;
                            } else {
                                parser_error(parser, "Expected NULL or DEFAULT after SET");
                                return NULL;
                            }
                        } else {
                            parser_error(parser, "Expected referential action after ON UPDATE");
                            return NULL;
                        }
                    }
                }
            } else if (parser_match(parser, TOKEN_UPDATE)) {
                /* ON UPDATE without ON DELETE */
                constraint->constraint.foreign_key.has_on_update = true;
                if (parser_match(parser, TOKEN_NO)) {
                    if (!parser_expect(parser, TOKEN_ACTION, "Expected ACTION after NO")) {
                        return NULL;
                    }
                    constraint->constraint.foreign_key.on_update = REF_ACTION_NO_ACTION;
                } else if (parser_match(parser, TOKEN_RESTRICT)) {
                    constraint->constraint.foreign_key.on_update = REF_ACTION_RESTRICT;
                } else if (parser_match(parser, TOKEN_CASCADE)) {
                    constraint->constraint.foreign_key.on_update = REF_ACTION_CASCADE;
                } else if (parser_match(parser, TOKEN_SET)) {
                    if (parser_match(parser, TOKEN_NULL)) {
                        constraint->constraint.foreign_key.on_update = REF_ACTION_SET_NULL;
                    } else if (parser_match(parser, TOKEN_DEFAULT)) {
                        constraint->constraint.foreign_key.on_update = REF_ACTION_SET_DEFAULT;
                    } else {
                        parser_error(parser, "Expected NULL or DEFAULT after SET");
                        return NULL;
                    }
                } else {
                    parser_error(parser, "Expected referential action after ON UPDATE");
                    return NULL;
                }
            }
        }
    } else if (parser_match(parser, TOKEN_EXCLUDE)) {
        constraint->type = TABLE_CONSTRAINT_EXCLUDE;
        /* TODO: Parse exclude constraint */
        parser_error(parser, "EXCLUDE constraints not fully implemented yet");
        return NULL;
    } else {
        parser_error(parser, "Expected table constraint type");
        return NULL;
    }

    return constraint;
}

/* Parse constraint attributes */
static bool parse_constraint_attributes(Parser *parser, ColumnConstraint *constraint) {
    /* Parse DEFERRABLE/NOT DEFERRABLE */
    if (parser_match(parser, TOKEN_DEFERRABLE)) {
        constraint->has_deferrable = true;
        constraint->deferrable = true;
        constraint->not_deferrable = false;
    }
    /* Note: NOT DEFERRABLE parsing is intentionally NOT here because NOT is ambiguous */
    /* (could be NOT NULL, NOT DEFERRABLE, NOT ENFORCED) */
    /* For now, we don't support NOT DEFERRABLE to avoid conflicts with NOT NULL */

    /* Parse INITIALLY DEFERRED/IMMEDIATE */
    if (parser_match(parser, TOKEN_INITIALLY)) {
        constraint->has_initially = true;
        if (parser_match(parser, TOKEN_DEFERRED)) {
            constraint->initially_deferred = true;
            constraint->initially_immediate = false;
        } else if (parser_match(parser, TOKEN_IMMEDIATE)) {
            constraint->initially_deferred = false;
            constraint->initially_immediate = true;
        } else {
            parser_error(parser, "Expected DEFERRED or IMMEDIATE after INITIALLY");
            return false;
        }
    }

    /* Parse ENFORCED/NOT ENFORCED */
    if (parser_match(parser, TOKEN_ENFORCED)) {
        constraint->has_enforced = true;
        constraint->enforced = true;
        constraint->not_enforced = false;
    }
    /* Note: NOT ENFORCED parsing is intentionally NOT here to avoid conflicts with NOT NULL */

    return true;
}

/* Parse expression (simplified - just grab tokens until we hit a delimiter) */
Expression *parse_expression(Parser *parser) {
    StringBuilder *sb = sb_create();
    if (!sb) {
        parser_error(parser, "Out of memory");
        return NULL;
    }

    int paren_depth = 0;
    bool first_token = true;

    while (!parser_check(parser, TOKEN_EOF)) {
        /* Stop at statement/clause delimiters */
        if (paren_depth == 0) {
            if (parser_check(parser, TOKEN_COMMA) ||
                parser_check(parser, TOKEN_SEMICOLON) ||
                parser_check(parser, TOKEN_RPAREN) ||
                parser_check(parser, TOKEN_CHECK) ||
                parser_check(parser, TOKEN_CONSTRAINT) ||
                parser_check(parser, TOKEN_NOT) ||
                parser_check(parser, TOKEN_NULL) ||
                parser_check(parser, TOKEN_UNIQUE) ||
                parser_check(parser, TOKEN_PRIMARY) ||
                parser_check(parser, TOKEN_REFERENCES) ||
                parser_check(parser, TOKEN_COLLATE) ||
                parser_check(parser, TOKEN_NO) ||
                parser_check(parser, TOKEN_DEFERRABLE) ||
                parser_check(parser, TOKEN_INITIALLY) ||
                parser_check(parser, TOKEN_ENFORCED)) {
                break;
            }
        }

        /* Track parentheses */
        if (parser_check(parser, TOKEN_LPAREN)) {
            paren_depth++;
        } else if (parser_check(parser, TOKEN_RPAREN)) {
            if (paren_depth > 0) {
                paren_depth--;
            } else {
                break; /* Unmatched closing paren - end expression */
            }
        }

        /* Append token to expression */
        /* Add space before token unless it's a parenthesis following another token */
        if (!first_token) {
            /* Don't add space before opening paren or after opening paren */
            /* Don't add space before closing paren */
            if (parser->current.type != TOKEN_LPAREN &&
                parser->current.type != TOKEN_RPAREN &&
                parser->previous.type != TOKEN_LPAREN) {
                sb_append_char(sb, ' ');
            }
        }
        first_token = false;
        sb_append(sb, parser->current.lexeme);
        parser_advance(parser);
    }

    char *expr_str = sb_to_string(sb);
    sb_free(sb);

    if (!expr_str || strlen(expr_str) == 0) {
        free(expr_str);
        parser_error(parser, "Expected expression");
        return NULL;
    }

    Expression *expr = expression_alloc(parser->memory_ctx, expr_str);
    free(expr_str);

    return expr;
}

/* Parse sequence options for GENERATED IDENTITY constraints */
static SequenceOptions *parse_sequence_options(Parser *parser) {
    SequenceOptions *opts = mem_calloc(parser->memory_ctx, 1, sizeof(SequenceOptions));
    if (!opts) {
        parser_error(parser, "Out of memory");
        return NULL;
    }

    /* Initialize all flags to false */
    opts->has_increment = false;
    opts->has_start = false;
    opts->has_minvalue = false;
    opts->is_no_minvalue = false;
    opts->has_maxvalue = false;
    opts->is_no_maxvalue = false;
    opts->has_cache = false;
    opts->has_cycle = false;

    /* Parse sequence options in any order */
    while (!parser_check(parser, TOKEN_RPAREN) && !parser_check(parser, TOKEN_EOF)) {
        if (parser_match(parser, TOKEN_INCREMENT)) {
            if (parser_match(parser, TOKEN_BY)) {
                if (!parser_check(parser, TOKEN_NUMBER)) {
                    parser_error(parser, "Expected number after INCREMENT BY");
                    return NULL;
                }
                opts->has_increment = true;
                opts->increment_by = atol(parser->current.lexeme);
                parser_advance(parser);
            } else {
                parser_error(parser, "Expected BY after INCREMENT");
                return NULL;
            }
        } else if (parser_match(parser, TOKEN_START)) {
            if (parser_match(parser, TOKEN_WITH)) {
                if (!parser_check(parser, TOKEN_NUMBER)) {
                    parser_error(parser, "Expected number after START WITH");
                    return NULL;
                }
                opts->has_start = true;
                opts->start_with = atol(parser->current.lexeme);
                parser_advance(parser);
            } else {
                parser_error(parser, "Expected WITH after START");
                return NULL;
            }
        } else if (parser_match(parser, TOKEN_NO)) {
            if (parser_match(parser, TOKEN_MINVALUE)) {
                opts->has_minvalue = false;
                opts->is_no_minvalue = true;
            } else if (parser_match(parser, TOKEN_MAXVALUE)) {
                opts->has_maxvalue = false;
                opts->is_no_maxvalue = true;
            } else if (parser_match(parser, TOKEN_CYCLE)) {
                opts->has_cycle = true;
                opts->cycle = false;
            } else {
                parser_error(parser, "Expected MINVALUE, MAXVALUE, or CYCLE after NO");
                return NULL;
            }
        } else if (parser_match(parser, TOKEN_MINVALUE)) {
            if (!parser_check(parser, TOKEN_NUMBER)) {
                parser_error(parser, "Expected number after MINVALUE");
                return NULL;
            }
            opts->has_minvalue = true;
            opts->is_no_minvalue = false;
            opts->minvalue = atol(parser->current.lexeme);
            parser_advance(parser);
        } else if (parser_match(parser, TOKEN_MAXVALUE)) {
            if (!parser_check(parser, TOKEN_NUMBER)) {
                parser_error(parser, "Expected number after MAXVALUE");
                return NULL;
            }
            opts->has_maxvalue = true;
            opts->is_no_maxvalue = false;
            opts->maxvalue = atol(parser->current.lexeme);
            parser_advance(parser);
        } else if (parser_match(parser, TOKEN_CACHE)) {
            if (!parser_check(parser, TOKEN_NUMBER)) {
                parser_error(parser, "Expected number after CACHE");
                return NULL;
            }
            opts->has_cache = true;
            opts->cache = atol(parser->current.lexeme);
            parser_advance(parser);
        } else if (parser_match(parser, TOKEN_CYCLE)) {
            opts->has_cycle = true;
            opts->cycle = true;
        } else {
            /* Unknown option, stop parsing */
            break;
        }
    }

    return opts;
}

/* Parse WITH options for storage parameters */
StorageParameterList *parse_with_options(Parser *parser) {
    if (!parser_match(parser, TOKEN_WITH)) {
        return NULL;
    }

    if (!parser_expect(parser, TOKEN_LPAREN, "Expected '(' after WITH")) {
        return NULL;
    }

    StorageParameterList *list = mem_calloc(parser->memory_ctx, 1, sizeof(StorageParameterList));
    if (!list) {
        parser_error(parser, "Out of memory");
        return NULL;
    }

    int capacity = 4;
    list->parameters = mem_calloc(parser->memory_ctx, capacity, sizeof(StorageParameter));
    if (!list->parameters) {
        parser_error(parser, "Out of memory");
        return NULL;
    }
    list->count = 0;

    do {
        if (!parser_check(parser, TOKEN_IDENTIFIER)) {
            parser_error(parser, "Expected storage parameter name");
            return NULL;
        }

        if (list->count >= capacity) {
            capacity *= 2;
            StorageParameter *new_params = mem_calloc(parser->memory_ctx, capacity, sizeof(StorageParameter));
            if (!new_params) {
                parser_error(parser, "Out of memory");
                return NULL;
            }
            memcpy(new_params, list->parameters, sizeof(StorageParameter) * list->count);
            list->parameters = new_params;
        }

        list->parameters[list->count].name = mem_strdup(parser->memory_ctx, parser->current.lexeme);
        parser_advance(parser);

        if (!parser_expect(parser, TOKEN_EQUAL, "Expected '=' after parameter name")) {
            return NULL;
        }

        /* Parameter value can be identifier, number, or string */
        if (parser_check(parser, TOKEN_IDENTIFIER) ||
            parser_check(parser, TOKEN_NUMBER) ||
            parser_check(parser, TOKEN_STRING_LITERAL)) {
            list->parameters[list->count].value = mem_strdup(parser->memory_ctx, parser->current.lexeme);
            parser_advance(parser);
        } else {
            parser_error(parser, "Expected parameter value");
            return NULL;
        }

        list->count++;
    } while (parser_match(parser, TOKEN_COMMA));

    if (!parser_expect(parser, TOKEN_RPAREN, "Expected ')' after WITH options")) {
        return NULL;
    }

    return list;
}

/* Parse index parameters (USING, WITH, TABLESPACE) */
static IndexParameters *parse_index_parameters(Parser *parser) {
    IndexParameters *params = NULL;
    StorageParameterList *with_opts = NULL;
    char *tablespace = NULL;

    /* Parse USING index_method (parse but don't store - btree is default) */
    if (parser_match(parser, TOKEN_USING)) {
        if (!parser_check(parser, TOKEN_IDENTIFIER)) {
            parser_error(parser, "Expected index method after USING");
            return NULL;
        }
        /* Skip the index method - it's typically btree for UNIQUE/PK and isn't stored in IndexParameters */
        parser_advance(parser);
    }

    /* Parse WITH (...) */
    with_opts = parse_with_options(parser);

    /* Parse TABLESPACE tablespace_name */
    if (parser_match(parser, TOKEN_TABLESPACE)) {
        if (!parser_check(parser, TOKEN_IDENTIFIER)) {
            parser_error(parser, "Expected tablespace name after TABLESPACE");
            return NULL;
        }
        tablespace = mem_strdup(parser->memory_ctx, parser->current.lexeme);
        parser_advance(parser);
    }

    /* Only allocate if we found at least one parameter we're storing */
    if (with_opts || tablespace) {
        params = mem_calloc(parser->memory_ctx, 1, sizeof(IndexParameters));
        if (!params) {
            parser_error(parser, "Out of memory");
            return NULL;
        }
        params->include = NULL;  /* INCLUDE is not supported in column constraints */
        params->with_options = with_opts;
        params->tablespace_name = tablespace;
    }

    return params;
}
