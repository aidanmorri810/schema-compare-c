#include "../test_framework.h"
#include "compare.h"
#include "parser.h"
#include "pg_create_table.h"
#include "diff.h"
#include "sc_memory.h"
#include "utils.h"
#include <string.h>

/* Helper to parse a table from file */
static CreateTableStmt *parse_table_from_file(const char *filename) {
    char *sql = read_file_to_string(filename);
    if (!sql) {
        return NULL;
    }

    Parser *parser = parser_create(sql);
    free(sql);

    if (!parser) {
        return NULL;
    }

    CreateTableStmt *stmt = parser_parse_create_table(parser);
    parser_destroy(parser);

    return stmt;
}

/* Test: Compare identical Sakila tables */
TEST_CASE(compare_integration, compare_identical_actor_tables) {
    MemoryContext *ctx = memory_context_create("test_compare_integration");
    ASSERT_NOT_NULL(ctx);

    CreateTableStmt *t1 = parse_table_from_file("tests/data/silka/tables/actor.sql");
    CreateTableStmt *t2 = parse_table_from_file("tests/data/silka/tables/actor.sql");

    ASSERT_NOT_NULL(t1);
    ASSERT_NOT_NULL(t2);

    CompareOptions *opts = compare_options_default();
    TableDiff *diff = compare_tables(t1, t2, opts, ctx);

    /* Identical tables should show no modifications */
    if (diff) {
        ASSERT_FALSE(diff->table_modified);
    }

    compare_options_free(opts);
    memory_context_destroy(ctx);
    TEST_PASS();
}

/* Test: Compare different Sakila tables */
TEST_CASE(compare_integration, compare_different_tables) {
    MemoryContext *ctx = memory_context_create("test_compare_integration");
    ASSERT_NOT_NULL(ctx);

    CreateTableStmt *actor = parse_table_from_file("tests/data/silka/tables/actor.sql");
    CreateTableStmt *film = parse_table_from_file("tests/data/silka/tables/film.sql");

    ASSERT_NOT_NULL(actor);
    ASSERT_NOT_NULL(film);

    /* Different tables - verify they have different names */
    ASSERT_TRUE(strcmp(actor->table_name, film->table_name) != 0);

    memory_context_destroy(ctx);
    TEST_PASS();
}

/* Test: Parse and compare modified actor table */
TEST_CASE(compare_integration, compare_modified_actor) {
    MemoryContext *ctx = memory_context_create("test_compare_integration");
    ASSERT_NOT_NULL(ctx);

    /* Original actor table */
    CreateTableStmt *original = parse_table_from_file("tests/data/silka/tables/actor.sql");
    ASSERT_NOT_NULL(original);

    /* Modified version - manually create a modified table */
    const char *modified_sql =
        "CREATE TABLE actor (\n"
        "    actor_id integer GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,\n"
        "    first_name varchar(45) NOT NULL,\n"
        "    last_name varchar(45) NOT NULL,\n"
        "    email varchar(100),\n"  /* Added column */
        "    last_update timestamp NOT NULL DEFAULT now()\n"
        ");";

    Parser *parser = parser_create(modified_sql);
    ASSERT_NOT_NULL(parser);

    CreateTableStmt *modified = parser_parse_create_table(parser);
    ASSERT_NOT_NULL(modified);

    /* Compare the two */
    CompareOptions *opts = compare_options_default();
    TableDiff *diff = compare_tables(original, modified, opts, ctx);

    /* Should detect modifications */
    if (diff) {
        /* Modified table should show some changes */
        /* The exact behavior depends on implementation */
        ASSERT_NOT_NULL(diff->table_name);
    }

    parser_destroy(parser);
    compare_options_free(opts);
    memory_context_destroy(ctx);
    TEST_PASS();
}

/* Test: Compare multiple Sakila tables in batch */
TEST_CASE(compare_integration, compare_multiple_tables) {
    MemoryContext *ctx = memory_context_create("test_compare_integration");
    ASSERT_NOT_NULL(ctx);

    const char *table_files[] = {
        "tests/data/silka/tables/actor.sql",
        "tests/data/silka/tables/language.sql",
        "tests/data/silka/tables/country.sql",
    };

    CreateTableStmt *tables1[3];
    CreateTableStmt *tables2[3];
    int count = 0;

    /* Parse all tables twice */
    for (int i = 0; i < 3; i++) {
        tables1[i] = parse_table_from_file(table_files[i]);
        tables2[i] = parse_table_from_file(table_files[i]);

        if (tables1[i] && tables2[i]) {
            count++;
        }
    }

    /* Should have parsed at least 2 tables */
    ASSERT_TRUE(count >= 2);

    /* Compare schemas */
    CompareOptions *opts = compare_options_default();
    SchemaDiff *diff = compare_schemas(tables1, count, tables2, count, opts, ctx);

    /* Identical schemas should show no differences */
    if (diff) {
        ASSERT_EQ(diff->tables_added, 0);
        ASSERT_EQ(diff->tables_removed, 0);
    }

    compare_options_free(opts);
    memory_context_destroy(ctx);
    TEST_PASS();
}

/* Test: Type normalization with real data */
TEST_CASE(compare_integration, type_normalization_real_world) {
    MemoryContext *ctx = memory_context_create("test_compare_integration");
    ASSERT_NOT_NULL(ctx);

    /* Create two equivalent tables with different type aliases */
    const char *sql1 =
        "CREATE TABLE test1 (\n"
        "    id int4 PRIMARY KEY,\n"
        "    name varchar(50)\n"
        ");";

    const char *sql2 =
        "CREATE TABLE test1 (\n"
        "    id integer PRIMARY KEY,\n"
        "    name varchar(50)\n"
        ");";

    Parser *p1 = parser_create(sql1);
    Parser *p2 = parser_create(sql2);

    ASSERT_NOT_NULL(p1);
    ASSERT_NOT_NULL(p2);

    CreateTableStmt *t1 = parser_parse_create_table(p1);
    CreateTableStmt *t2 = parser_parse_create_table(p2);

    ASSERT_NOT_NULL(t1);
    ASSERT_NOT_NULL(t2);

    /* Compare with type normalization enabled */
    CompareOptions *opts = compare_options_default();
    opts->normalize_types = true;

    TableDiff *diff = compare_tables(t1, t2, opts, ctx);

    /* With normalization, int4 and integer should be treated as the same */
    if (diff) {
        /* Should show minimal or no differences */
        ASSERT_FALSE(diff->type_changed);
    }

    parser_destroy(p1);
    parser_destroy(p2);
    compare_options_free(opts);
    memory_context_destroy(ctx);
    TEST_PASS();
}

/* Test: Case insensitive comparison */
TEST_CASE(compare_integration, case_insensitive_comparison) {
    MemoryContext *ctx = memory_context_create("test_compare_integration");
    ASSERT_NOT_NULL(ctx);

    const char *sql1 = "CREATE TABLE Users (id INTEGER PRIMARY KEY);";
    const char *sql2 = "CREATE TABLE users (id INTEGER PRIMARY KEY);";

    Parser *p1 = parser_create(sql1);
    Parser *p2 = parser_create(sql2);

    CreateTableStmt *t1 = parser_parse_create_table(p1);
    CreateTableStmt *t2 = parser_parse_create_table(p2);

    ASSERT_NOT_NULL(t1);
    ASSERT_NOT_NULL(t2);

    /* Compare with case insensitive mode */
    CompareOptions *opts = compare_options_default();
    opts->case_sensitive = false;

    /* Should treat Users and users as the same table */
    bool equal = names_equal(t1->table_name, t2->table_name, opts);
    ASSERT_TRUE(equal);

    parser_destroy(p1);
    parser_destroy(p2);
    compare_options_free(opts);
    memory_context_destroy(ctx);
    TEST_PASS();
}

/* Test: End-to-end workflow with real Sakila data */
TEST_CASE(compare_integration, end_to_end_workflow) {
    MemoryContext *ctx = memory_context_create("test_compare_integration");
    ASSERT_NOT_NULL(ctx);

    /* 1. Parse source schema */
    CreateTableStmt *source = parse_table_from_file("tests/data/silka/tables/actor.sql");
    ASSERT_NOT_NULL(source);

    /* 2. Parse target schema (same for now) */
    CreateTableStmt *target = parse_table_from_file("tests/data/silka/tables/actor.sql");
    ASSERT_NOT_NULL(target);

    /* 3. Compare schemas */
    CompareOptions *opts = compare_options_default();
    TableDiff *diff = compare_tables(source, target, opts, ctx);

    /* 4. Verify results */
    if (diff) {
        /* Identical schemas should show no modifications */
        ASSERT_FALSE(diff->table_modified);
        ASSERT_STR_EQ(diff->table_name, "actor");
    }

    compare_options_free(opts);
    memory_context_destroy(ctx);
    TEST_PASS();
}

/* Test suite definition */
static TestCase compare_integration_tests[] = {
    /* TODO: These depend on read_file_to_string which may not be working */
    {"compare_identical_actor_tables", test_compare_integration_compare_identical_actor_tables, "compare_integration"},
    {"compare_different_tables", test_compare_integration_compare_different_tables, "compare_integration"},
    {"compare_modified_actor", test_compare_integration_compare_modified_actor, "compare_integration"},
    {"compare_multiple_tables", test_compare_integration_compare_multiple_tables, "compare_integration"},
    {"type_normalization_real_world", test_compare_integration_type_normalization_real_world, "compare_integration"},
    {"case_insensitive_comparison", test_compare_integration_case_insensitive_comparison, "compare_integration"},
    {"end_to_end_workflow", test_compare_integration_end_to_end_workflow, "compare_integration"},
};

void run_compare_integration_tests(void) {
    run_test_suite("compare_integration", NULL, NULL, compare_integration_tests,
                   sizeof(compare_integration_tests) / sizeof(compare_integration_tests[0]));
}
